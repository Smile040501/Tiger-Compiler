(* User Declarations *)

(* The type of should match with type of `pos` in tiger.grm *)
type pos    = int

(* Stuff done to make use of Tokens module generated by tiger.grm *)
type svalue         = Tokens.svalue
type ('a, 'b) token = ('a, 'b) Tokens.token
type lexresult      = (svalue, pos) token

(* Keeps track of the line number *)
val lineNo    : pos ref = ref 1

(* Keeps track of the position in line
  It is different from `yypos` as `yypos` is relative to the start of the file *)
val posInLine : pos ref = ref 1

(* Updates the input reference variable *)
fun incRef   x n = (x := !x + n)
fun decRef   x n = (x := !x - n)
fun resetRef x   = (x := 1)

(* Called by the lexer when the end of the input stream is reached. *)
fun eof () = ((resetRef lineNo); (resetRef posInLine); Tokens.EOF (!lineNo, !lineNo))

(* Some helper functions during lexing *)

(* ord : char -> int  (* Returns the ASCII value of the character *) *)
fun charsToInt m (x :: xs) = charsToInt (10 * m + ((ord x) - (ord #"0"))) xs
  | charsToInt m []        = m

fun toSigned (#"-" :: xs) = ~ (charsToInt 0 xs)
  | toSigned (#"~" :: xs) = ~ (charsToInt 0 xs)
  | toSigned (#"+" :: xs) =    charsToInt 0 xs
  | toSigned xs           =    charsToInt 0 xs

(* String.explode : string -> char list *)
val toInt = toSigned o String.explode

(* Counts number of newlines based on the \n's encountered in the input *)
val newLineCount = List.length o List.filter (fn x => x = #"\n") o String.explode

(* Syntax error handling *)
exception SyntaxError of string

fun syntaxErr text =
        let
            val _ = Utils.printErr ("Syntax error on line " ^ (Int.toString (!lineNo)) ^ ".\n" ^
                                            "Illegal character '" ^ text ^ "' found at position " ^
                                                (Int.toString (!posInLine)) ^ ".\n")
            val _ = resetRef lineNo
            val _ = resetRef posInLine
        in
            raise SyntaxError "Syntax Error"
        end

%%

%header (functor TigerLexFun(structure Tokens: Tiger_TOKENS));

space    = [\ ];
tabspace = [\t];
ws       = [\ \t];
digit    = [0-9];
id       = [a-zA-Z][a-zA-Z0-9_]*;
nl       = (\n|\r\n|\r|\n\r);
alpha    = [a-zA-Z];

%%

<INITIAL> {nl}({ws}*{nl})*      => ((incRef lineNo (newLineCount yytext)); (resetRef posInLine);
                                    lex()
                                  );
<INITIAL> {space}+              => ((incRef posInLine (size yytext));
                                    lex()
                                  );

<INITIAL> {tabspace}+           => ((incRef posInLine (8 * (size yytext)));
                                    lex()
                                  );

<INITIAL> "print"               => ((incRef posInLine (size yytext));
                                    Tokens.PRINT  (yypos, yypos + (size yytext))
                                  );
<INITIAL> "println"             => ((incRef posInLine (size yytext));
                                    Tokens.PRINTLN(yypos, yypos + (size yytext))
                                  );

<INITIAL> "for"                 => ((incRef posInLine (size yytext));
                                    Tokens.FOR (yypos, yypos + (size yytext))
                                  );
<INITIAL> "to"                  => ((incRef posInLine (size yytext));
                                    Tokens.TO  (yypos, yypos + (size yytext))
                                  );
<INITIAL> "by"                  => ((incRef posInLine (size yytext));
                                    Tokens.BY  (yypos, yypos + (size yytext))
                                  );
<INITIAL> "do"                  => ((incRef posInLine (size yytext));
                                    Tokens.DO  (yypos, yypos + (size yytext))
                                  );
<INITIAL> "done"                => ((incRef posInLine (size yytext));
                                    Tokens.DONE(yypos, yypos + (size yytext))
                                  );

<INITIAL> ":="                  => ((incRef posInLine (size yytext));
                                    Tokens.ASSIGN   (yypos, yypos + (size yytext))
                                  );
<INITIAL> ";"                   => ((incRef posInLine (size yytext));
                                    Tokens.SEMICOLON(yypos, yypos + (size yytext))
                                  );

<INITIAL> "+"                   => ((incRef posInLine (size yytext));
                                    Tokens.PLUS (yypos, yypos + (size yytext))
                                  );
<INITIAL> "-"                   => ((incRef posInLine (size yytext));
                                    Tokens.MINUS(yypos, yypos + (size yytext))
                                  );
<INITIAL> "*"                   => ((incRef posInLine (size yytext));
                                    Tokens.MUL  (yypos, yypos + (size yytext))
                                  );
<INITIAL> "/"                   => ((incRef posInLine (size yytext));
                                    Tokens.DIV  (yypos, yypos + (size yytext))
                                  );

<INITIAL> "("                   => ((incRef posInLine (size yytext));
                                    Tokens.LPAREN(yypos, yypos + (size yytext))
                                  );
<INITIAL> ")"                   => ((incRef posInLine (size yytext));
                                    Tokens.RPAREN(yypos, yypos + (size yytext))
                                  );


<INITIAL> {digit}+              => ((incRef posInLine (size yytext));
                                    Tokens.INT(toInt yytext, yypos, yypos + (size yytext))
                                  );
<INITIAL> {id}                  => ((incRef posInLine (size yytext));
                                    Tokens.ID (yytext, yypos, yypos + (size yytext))
                                  );

.                               => (syntaxErr yytext);
